import React, { useState } from 'react';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import type { SentimentResult } from '../../../shared/contracts/api';

interface PDFAuditExporterProps {
  results: SentimentResult[];
  metadata?: {
    projectName?: string;
    author?: string;
    organization?: string;
    description?: string;
  };
  onExportComplete?: (blob: Blob) => void;
  onError?: (error: Error) => void;
}

export const PDFAuditExporter: React.FC<PDFAuditExporterProps> = ({
  results,
  metadata = {},
  onExportComplete,
  onError
}) => {
  const [isExporting, setIsExporting] = useState(false);
  const [progress, setProgress] = useState(0);

  const generateAuditReport = async () => {
    setIsExporting(true);
    setProgress(0);

    try {
      const doc = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
      });

      // Cover Page
      addCoverPage(doc, metadata, results.length);
      setProgress(10);

      // Executive Summary
      doc.addPage();
      addExecutiveSummary(doc, results);
      setProgress(20);

      // Statistical Analysis
      doc.addPage();
      addStatisticalAnalysis(doc, results);
      setProgress(30);

      // Sentiment Timeline
      doc.addPage();
      addSentimentTimeline(doc, results);
      setProgress(40);

      // Key Findings
      doc.addPage();
      addKeyFindings(doc, results);
      setProgress(50);

      // Compliance & Risk Assessment
      doc.addPage();
      addComplianceSection(doc, results);
      setProgress(60);

      // Detailed Results Table
      doc.addPage();
      addDetailedResults(doc, results);
      setProgress(80);

      // Methodology & Appendix
      doc.addPage();
      addMethodology(doc);
      setProgress(90);

      // Add page numbers and footers
      addPageNumbersAndFooters(doc);
      
      const blob = doc.output('blob');
      setProgress(100);

      if (onExportComplete) {
        onExportComplete(blob);
      } else {
        // Download directly
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `sentiment-audit-report-${new Date().toISOString().split('T')[0]}.pdf`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

    } catch (error) {
      console.error('PDF generation error:', error);
      if (onError) {
        onError(error as Error);
      }
    } finally {
      setIsExporting(false);
      setProgress(0);
    }
  };

  const addCoverPage = (doc: jsPDF, metadata: any, totalRecords: number) => {
    // Background color
    doc.setFillColor(245, 247, 250);
    doc.rect(0, 0, 210, 297, 'F');

    // Title
    doc.setFontSize(32);
    doc.setTextColor(26, 32, 44);
    doc.text('Sentiment Analysis', 105, 50, { align: 'center' });
    doc.setFontSize(24);
    doc.text('Audit Report', 105, 65, { align: 'center' });

    // Metadata
    doc.setFontSize(14);
    doc.setTextColor(100, 116, 139);
    const yOffset = 100;
    
    if (metadata.projectName) {
      doc.text(`Project: ${metadata.projectName}`, 105, yOffset, { align: 'center' });
    }
    
    if (metadata.organization) {
      doc.text(`Organization: ${metadata.organization}`, 105, yOffset + 10, { align: 'center' });
    }

    // Stats box
    doc.setFillColor(255, 255, 255);
    doc.roundedRect(50, 140, 110, 60, 5, 5, 'F');
    doc.setDrawColor(226, 232, 240);
    doc.roundedRect(50, 140, 110, 60, 5, 5, 'S');

    doc.setFontSize(12);
    doc.setTextColor(71, 85, 105);
    doc.text('Report Summary', 105, 155, { align: 'center' });
    
    doc.setFontSize(10);
    doc.text(`Total Records Analyzed: ${totalRecords.toLocaleString()}`, 105, 170, { align: 'center' });
    doc.text(`Generated: ${new Date().toLocaleDateString()}`, 105, 180, { align: 'center' });
    doc.text(`Time: ${new Date().toLocaleTimeString()}`, 105, 190, { align: 'center' });

    // Footer
    doc.setFontSize(10);
    doc.setTextColor(148, 163, 184);
    doc.text('Generated by Sentiment Analysis Workbench', 105, 270, { align: 'center' });
  };

  const addExecutiveSummary = (doc: jsPDF, results: SentimentResult[]) => {
    doc.setFontSize(20);
    doc.setTextColor(26, 32, 44);
    doc.text('Executive Summary', 20, 30);

    const stats = calculateStatistics(results);

    // Summary text
    doc.setFontSize(11);
    doc.setTextColor(71, 85, 105);
    const summaryText = `This report presents a comprehensive analysis of ${results.length.toLocaleString()} sentiment data points. ` +
      `The analysis reveals an average sentiment score of ${stats.averageScore.toFixed(3)}, ` +
      `with ${stats.positivePercent.toFixed(1)}% positive, ${stats.negativePercent.toFixed(1)}% negative, ` +
      `and ${stats.neutralPercent.toFixed(1)}% neutral sentiments. ` +
      `The average confidence level across all analyses is ${(stats.averageConfidence * 100).toFixed(1)}%.`;

    const lines = doc.splitTextToSize(summaryText, 170);
    doc.text(lines, 20, 45);

    // Key metrics boxes
    const metrics = [
      { label: 'Positive Sentiment', value: `${stats.positivePercent.toFixed(1)}%`, color: [16, 185, 129] },
      { label: 'Negative Sentiment', value: `${stats.negativePercent.toFixed(1)}%`, color: [239, 68, 68] },
      { label: 'Average Confidence', value: `${(stats.averageConfidence * 100).toFixed(1)}%`, color: [59, 130, 246] },
      { label: 'Data Quality Score', value: calculateDataQualityScore(results), color: [168, 85, 247] }
    ];

    let yPos = 80;
    metrics.forEach((metric, index) => {
      if (index % 2 === 0) {
        drawMetricBox(doc, 20, yPos, metric);
      } else {
        drawMetricBox(doc, 110, yPos, metric);
        yPos += 35;
      }
    });
  };

  const drawMetricBox = (doc: jsPDF, x: number, y: number, metric: any) => {
    doc.setFillColor(248, 250, 252);
    doc.roundedRect(x, y, 80, 30, 3, 3, 'F');
    
    doc.setFontSize(9);
    doc.setTextColor(100, 116, 139);
    doc.text(metric.label, x + 40, y + 10, { align: 'center' });
    
    doc.setFontSize(16);
    doc.setTextColor(...metric.color);
    doc.text(metric.value, x + 40, y + 22, { align: 'center' });
  };

  const addStatisticalAnalysis = (doc: jsPDF, results: SentimentResult[]) => {
    doc.setFontSize(20);
    doc.setTextColor(26, 32, 44);
    doc.text('Statistical Analysis', 20, 30);

    const stats = calculateDetailedStatistics(results);

    // Create data table
    const tableData = [
      ['Metric', 'Value'],
      ['Total Samples', results.length.toLocaleString()],
      ['Mean Sentiment Score', stats.mean.toFixed(4)],
      ['Median Sentiment Score', stats.median.toFixed(4)],
      ['Standard Deviation', stats.stdDev.toFixed(4)],
      ['Variance', stats.variance.toFixed(4)],
      ['Skewness', stats.skewness.toFixed(4)],
      ['Kurtosis', stats.kurtosis.toFixed(4)],
      ['95% Confidence Interval', `[${stats.ci95Lower.toFixed(4)}, ${stats.ci95Upper.toFixed(4)}]`]
    ];

    (doc as any).autoTable({
      startY: 45,
      head: [tableData[0]],
      body: tableData.slice(1),
      theme: 'striped',
      headStyles: {
        fillColor: [59, 130, 246],
        textColor: 255,
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 10,
        cellPadding: 5
      },
      columnStyles: {
        0: { fontStyle: 'bold' }
      }
    });

    // Add distribution chart placeholder
    const finalY = (doc as any).lastAutoTable.finalY + 20;
    doc.setFontSize(14);
    doc.text('Sentiment Distribution', 20, finalY);
    
    // Simple bar chart
    drawDistributionChart(doc, 20, finalY + 10, results);
  };

  const drawDistributionChart = (doc: jsPDF, x: number, y: number, results: SentimentResult[]) => {
    const stats = calculateStatistics(results);
    const barWidth = 40;
    const maxHeight = 60;

    // Positive bar
    doc.setFillColor(16, 185, 129);
    const posHeight = (stats.positivePercent / 100) * maxHeight;
    doc.rect(x, y + maxHeight - posHeight, barWidth, posHeight, 'F');
    doc.setFontSize(10);
    doc.text('Positive', x + barWidth/2, y + maxHeight + 10, { align: 'center' });
    doc.text(`${stats.positivePercent.toFixed(1)}%`, x + barWidth/2, y + maxHeight + 16, { align: 'center' });

    // Negative bar
    doc.setFillColor(239, 68, 68);
    const negHeight = (stats.negativePercent / 100) * maxHeight;
    doc.rect(x + barWidth + 10, y + maxHeight - negHeight, barWidth, negHeight, 'F');
    doc.text('Negative', x + barWidth + 10 + barWidth/2, y + maxHeight + 10, { align: 'center' });
    doc.text(`${stats.negativePercent.toFixed(1)}%`, x + barWidth + 10 + barWidth/2, y + maxHeight + 16, { align: 'center' });

    // Neutral bar
    doc.setFillColor(107, 114, 128);
    const neuHeight = (stats.neutralPercent / 100) * maxHeight;
    doc.rect(x + 2*(barWidth + 10), y + maxHeight - neuHeight, barWidth, neuHeight, 'F');
    doc.text('Neutral', x + 2*(barWidth + 10) + barWidth/2, y + maxHeight + 10, { align: 'center' });
    doc.text(`${stats.neutralPercent.toFixed(1)}%`, x + 2*(barWidth + 10) + barWidth/2, y + maxHeight + 16, { align: 'center' });
  };

  const addSentimentTimeline = (doc: jsPDF, results: SentimentResult[]) => {
    doc.setFontSize(20);
    doc.setTextColor(26, 32, 44);
    doc.text('Sentiment Timeline', 20, 30);

    // Group results by date
    const timeline = groupResultsByDate(results);
    const timelineData = Object.entries(timeline).map(([date, data]) => [
      date,
      data.positive.toString(),
      data.negative.toString(),
      data.neutral.toString(),
      data.avgScore.toFixed(3)
    ]);

    (doc as any).autoTable({
      startY: 45,
      head: [['Date', 'Positive', 'Negative', 'Neutral', 'Avg Score']],
      body: timelineData.slice(0, 20), // Limit to recent 20 dates
      theme: 'grid',
      headStyles: {
        fillColor: [59, 130, 246],
        textColor: 255,
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 9,
        cellPadding: 4
      }
    });
  };

  const addKeyFindings = (doc: jsPDF, results: SentimentResult[]) => {
    doc.setFontSize(20);
    doc.setTextColor(26, 32, 44);
    doc.text('Key Findings', 20, 30);

    const findings = generateKeyFindings(results);
    let yPos = 45;

    findings.forEach((finding, index) => {
      // Finding box
      doc.setFillColor(
        ...(finding.type === 'positive' ? [236, 253, 245] : 
            finding.type === 'warning' ? [254, 243, 199] : [254, 226, 226]) as [number, number, number]
      );
      doc.roundedRect(20, yPos, 170, 25, 3, 3, 'F');

      // Icon
      doc.setFontSize(16);
      doc.text(finding.type === 'positive' ? 'âœ“' : 
               finding.type === 'warning' ? 'âš ' : 'âœ—', 
               30, yPos + 15);

      // Text
      doc.setFontSize(10);
      doc.setTextColor(71, 85, 105);
      const lines = doc.splitTextToSize(finding.text, 140);
      doc.text(lines, 45, yPos + 10);

      yPos += 30;
    });
  };

  const addComplianceSection = (doc: jsPDF, results: SentimentResult[]) => {
    doc.setFontSize(20);
    doc.setTextColor(26, 32, 44);
    doc.text('Compliance & Risk Assessment', 20, 30);

    const riskMetrics = calculateRiskMetrics(results);

    // Risk level indicator
    const riskLevel = riskMetrics.overallRisk;
    const riskColor = riskLevel === 'low' ? [16, 185, 129] : 
                     riskLevel === 'medium' ? [251, 146, 60] : [239, 68, 68];

    doc.setFillColor(...riskColor);
    doc.roundedRect(20, 45, 170, 20, 3, 3, 'F');
    doc.setFontSize(14);
    doc.setTextColor(255, 255, 255);
    doc.text(`Overall Risk Level: ${riskLevel.toUpperCase()}`, 105, 57, { align: 'center' });

    // Compliance checklist
    const checklistData = [
      ['Compliance Area', 'Status', 'Notes'],
      ['Data Quality', riskMetrics.dataQuality, 'Based on confidence scores and completeness'],
      ['Sentiment Balance', riskMetrics.sentimentBalance, 'Distribution analysis of sentiment types'],
      ['Confidence Threshold', riskMetrics.confidenceCompliance, 'Percentage meeting minimum confidence'],
      ['Outlier Detection', riskMetrics.outlierStatus, 'Statistical anomaly detection'],
      ['Temporal Consistency', riskMetrics.temporalConsistency, 'Trend stability over time']
    ];

    (doc as any).autoTable({
      startY: 75,
      head: [checklistData[0]],
      body: checklistData.slice(1),
      theme: 'striped',
      headStyles: {
        fillColor: [59, 130, 246],
        textColor: 255,
        fontStyle: 'bold'
      },
      styles: {
        fontSize: 9,
        cellPadding: 4
      },
      columnStyles: {
        1: { 
          cellWidth: 30,
          halign: 'center'
        }
      }
    });
  };

  const addDetailedResults = (doc: jsPDF, results: SentimentResult[]) => {
    doc.setFontSize(20);
    doc.setTextColor(26, 32, 44);
    doc.text('Detailed Results Sample', 20, 30);

    // Prepare sample data (first 50 records)
    const sampleData = results.slice(0, 50).map((result, index) => [
      (index + 1).toString(),
      result.text.substring(0, 40) + (result.text.length > 40 ? '...' : ''),
      result.sentiment,
      result.score.toFixed(3),
      (result.confidence * 100).toFixed(1) + '%',
      new Date(result.createdAt).toLocaleDateString()
    ]);

    (doc as any).autoTable({
      startY: 45,
      head: [['#', 'Text', 'Sentiment', 'Score', 'Conf.', 'Date']],
      body: sampleData,
      theme: 'grid',
      headStyles: {
        fillColor: [59, 130, 246],
        textColor: 255,
        fontStyle: 'bold',
        fontSize: 8
      },
      styles: {
        fontSize: 7,
        cellPadding: 2
      },
      columnStyles: {
        0: { cellWidth: 10 },
        1: { cellWidth: 70 },
        2: { cellWidth: 25, halign: 'center' },
        3: { cellWidth: 20, halign: 'center' },
        4: { cellWidth: 20, halign: 'center' },
        5: { cellWidth: 25 }
      }
    });

    // Add note about full dataset
    const finalY = (doc as any).lastAutoTable.finalY + 10;
    doc.setFontSize(10);
    doc.setTextColor(100, 116, 139);
    doc.text(`Note: Showing first 50 of ${results.length.toLocaleString()} total records`, 20, finalY);
  };

  const addMethodology = (doc: jsPDF) => {
    doc.setFontSize(20);
    doc.setTextColor(26, 32, 44);
    doc.text('Methodology', 20, 30);

    doc.setFontSize(11);
    doc.setTextColor(71, 85, 105);
    
    const methodology = [
      'Data Collection: All sentiment data was collected and processed using the Sentiment Analysis Workbench platform.',
      'Analysis Method: Advanced natural language processing algorithms were applied to determine sentiment polarity and confidence scores.',
      'Quality Assurance: Results were filtered and validated based on confidence thresholds and statistical outlier detection.',
      'Reporting Standards: This report follows industry-standard practices for sentiment analysis auditing and compliance.'
    ];

    let yPos = 45;
    methodology.forEach((item, index) => {
      const lines = doc.splitTextToSize(`${index + 1}. ${item}`, 170);
      doc.text(lines, 20, yPos);
      yPos += lines.length * 6 + 5;
    });

    // Glossary
    doc.setFontSize(16);
    doc.setTextColor(26, 32, 44);
    doc.text('Glossary', 20, yPos + 10);

    doc.setFontSize(10);
    doc.setTextColor(71, 85, 105);
    const glossary = [
      'Sentiment Score: Numerical representation of sentiment polarity (-1 to 1)',
      'Confidence Score: Probability of correct sentiment classification (0-100%)',
      'Positive Sentiment: Score > 0.1',
      'Negative Sentiment: Score < -0.1',
      'Neutral Sentiment: Score between -0.1 and 0.1'
    ];

    yPos += 25;
    glossary.forEach(term => {
      doc.text(`â€¢ ${term}`, 25, yPos);
      yPos += 7;
    });
  };

  const addPageNumbersAndFooters = (doc: jsPDF) => {
    const pageCount = (doc as any).internal.getNumberOfPages();
    
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      
      // Page number
      doc.setFontSize(10);
      doc.setTextColor(148, 163, 184);
      doc.text(
        `Page ${i} of ${pageCount}`,
        doc.internal.pageSize.width - 30,
        doc.internal.pageSize.height - 10
      );
      
      // Footer
      doc.setFontSize(8);
      doc.text(
        'Confidential - Sentiment Analysis Audit Report',
        20,
        doc.internal.pageSize.height - 10
      );
    }
  };

  // Utility functions
  const calculateStatistics = (data: SentimentResult[]) => {
    const total = data.length;
    if (total === 0) {
      return {
        averageScore: 0,
        averageConfidence: 0,
        positive: 0,
        negative: 0,
        neutral: 0,
        positivePercent: 0,
        negativePercent: 0,
        neutralPercent: 0
      };
    }
    
    let totalScore = 0;
    let totalConfidence = 0;
    let positive = 0;
    let negative = 0;
    let neutral = 0;
    
    data.forEach(item => {
      totalScore += item.score || 0;
      totalConfidence += item.confidence || 0;
      
      if (item.score > 0.1) positive++;
      else if (item.score < -0.1) negative++;
      else neutral++;
    });
    
    return {
      averageScore: totalScore / total,
      averageConfidence: totalConfidence / total,
      positive,
      negative,
      neutral,
      positivePercent: (positive / total) * 100,
      negativePercent: (negative / total) * 100,
      neutralPercent: (neutral / total) * 100
    };
  };

  const calculateDetailedStatistics = (data: SentimentResult[]) => {
    const scores = data.map(d => d.score);
    const n = scores.length;
    
    // Sort for median
    const sorted = [...scores].sort((a, b) => a - b);
    const median = n % 2 === 0 
      ? (sorted[n/2 - 1] + sorted[n/2]) / 2 
      : sorted[Math.floor(n/2)];
    
    // Mean
    const mean = scores.reduce((a, b) => a + b, 0) / n;
    
    // Variance and standard deviation
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / n;
    const stdDev = Math.sqrt(variance);
    
    // Skewness
    const skewness = scores.reduce((sum, score) => sum + Math.pow((score - mean) / stdDev, 3), 0) / n;
    
    // Kurtosis
    const kurtosis = scores.reduce((sum, score) => sum + Math.pow((score - mean) / stdDev, 4), 0) / n - 3;
    
    // 95% Confidence interval
    const ci95 = 1.96 * (stdDev / Math.sqrt(n));
    
    return {
      mean,
      median,
      variance,
      stdDev,
      skewness,
      kurtosis,
      ci95Lower: mean - ci95,
      ci95Upper: mean + ci95
    };
  };

  const calculateDataQualityScore = (data: SentimentResult[]): string => {
    const avgConfidence = data.reduce((sum, d) => sum + d.confidence, 0) / data.length;
    const highConfidenceRatio = data.filter(d => d.confidence > 0.8).length / data.length;
    
    const score = (avgConfidence * 0.6 + highConfidenceRatio * 0.4) * 100;
    
    if (score >= 90) return 'A+';
    if (score >= 80) return 'A';
    if (score >= 70) return 'B';
    if (score >= 60) return 'C';
    return 'D';
  };

  const groupResultsByDate = (data: SentimentResult[]) => {
    const groups: Record<string, any> = {};
    
    data.forEach(item => {
      const date = new Date(item.createdAt).toLocaleDateString();
      if (!groups[date]) {
        groups[date] = { positive: 0, negative: 0, neutral: 0, total: 0, totalScore: 0 };
      }
      
      groups[date].total++;
      groups[date].totalScore += item.score;
      
      if (item.score > 0.1) groups[date].positive++;
      else if (item.score < -0.1) groups[date].negative++;
      else groups[date].neutral++;
    });
    
    // Calculate average score per day
    Object.keys(groups).forEach(date => {
      groups[date].avgScore = groups[date].totalScore / groups[date].total;
    });
    
    return groups;
  };

  const generateKeyFindings = (data: SentimentResult[]): any[] => {
    const stats = calculateStatistics(data);
    const findings = [];
    
    // Sentiment balance finding
    if (stats.positivePercent > 60) {
      findings.push({
        type: 'positive',
        text: `Strong positive sentiment trend detected with ${stats.positivePercent.toFixed(1)}% positive responses`
      });
    } else if (stats.negativePercent > 40) {
      findings.push({
        type: 'negative',
        text: `High negative sentiment detected with ${stats.negativePercent.toFixed(1)}% negative responses`
      });
    }
    
    // Confidence finding
    if (stats.averageConfidence > 0.85) {
      findings.push({
        type: 'positive',
        text: `Excellent data quality with average confidence of ${(stats.averageConfidence * 100).toFixed(1)}%`
      });
    } else if (stats.averageConfidence < 0.7) {
      findings.push({
        type: 'warning',
        text: `Lower confidence scores detected (avg: ${(stats.averageConfidence * 100).toFixed(1)}%) may impact reliability`
      });
    }
    
    // Outlier detection
    const outliers = data.filter(d => Math.abs(d.score) > 0.9).length;
    if (outliers > data.length * 0.05) {
      findings.push({
        type: 'warning',
        text: `${outliers} extreme sentiment scores detected, representing ${((outliers/data.length)*100).toFixed(1)}% of data`
      });
    }
    
    return findings;
  };

  const calculateRiskMetrics = (data: SentimentResult[]) => {
    const stats = calculateStatistics(data);
    
    // Data quality assessment
    const dataQuality = stats.averageConfidence > 0.8 ? 'Pass' : 
                       stats.averageConfidence > 0.6 ? 'Warning' : 'Fail';
    
    // Sentiment balance
    const maxPercent = Math.max(stats.positivePercent, stats.negativePercent, stats.neutralPercent);
    const sentimentBalance = maxPercent < 60 ? 'Pass' : 
                           maxPercent < 75 ? 'Warning' : 'Fail';
    
    // Confidence compliance
    const highConfidence = data.filter(d => d.confidence > 0.7).length / data.length;
    const confidenceCompliance = highConfidence > 0.8 ? 'Pass' : 
                               highConfidence > 0.6 ? 'Warning' : 'Fail';
    
    // Outlier detection
    const outlierRatio = data.filter(d => Math.abs(d.score) > 0.9).length / data.length;
    const outlierStatus = outlierRatio < 0.05 ? 'Pass' : 
                         outlierRatio < 0.1 ? 'Warning' : 'Fail';
    
    // Temporal consistency (simplified)
    const temporalConsistency = 'Pass'; // Would need time series analysis
    
    // Overall risk calculation
    const failCount = [dataQuality, sentimentBalance, confidenceCompliance, outlierStatus]
      .filter(s => s === 'Fail').length;
    const warningCount = [dataQuality, sentimentBalance, confidenceCompliance, outlierStatus]
      .filter(s => s === 'Warning').length;
    
    const overallRisk = failCount > 0 ? 'high' : 
                       warningCount > 2 ? 'medium' : 'low';
    
    return {
      dataQuality,
      sentimentBalance,
      confidenceCompliance,
      outlierStatus,
      temporalConsistency,
      overallRisk
    };
  };

  return (
    <div className="pdf-audit-exporter">
      <button
        onClick={generateAuditReport}
        disabled={isExporting || results.length === 0}
        className="pdf-export-button"
      >
        {isExporting ? (
          <>
            <span className="spinner"></span>
            Generating PDF... {progress}%
          </>
        ) : (
          <>
            ðŸ“‘ Generate PDF Audit Report
          </>
        )}
      </button>
      
      {isExporting && (
        <div className="export-progress-bar">
          <div 
            className="export-progress-fill" 
            style={{ width: `${progress}%` }}
          ></div>
        </div>
      )}
    </div>
  );
};

export default PDFAuditExporter;